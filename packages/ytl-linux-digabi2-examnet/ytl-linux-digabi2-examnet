#!/bin/bash

# Exit codes
readonly EXIT_CODE_MUST_BE_ROOT=1                     # The script must be executed by root or sudo
readonly EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_WAN=2  # Network device name (internet) is missing
readonly EXIT_CODE_NETWORK_DEVICE_MISSING_WAN=3       # Given network device name (internet) does not exist
readonly EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_LAN=4  # Network device name (local network) is missing
readonly EXIT_CODE_NETWORK_DEVICE_MISSING_LAN=5       # Given network device (local network) does not exist
readonly EXIT_CODE_IDENT_NETWORK_DEVICE_NAMES=6       # Two ident network names were given
readonly EXIT_CODE_MISSING_SERVER_NUMBER=7            # Server number is missing
readonly EXIT_CODE_ILLEGAL_SERVER_NUMBER=8            # Server number is not between 1-254 (or contains other than numbers)
readonly EXIT_CODE_BAD_FILE_PATH=9                    # When writing a file, the given path does not exist and could not be created
readonly EXIT_CODE_CANNOT_WRITE=10                    # Cannot write to the given filename
readonly EXIT_CODE_CANNOT_RESTART_RESOLVED=11         # Cannot restart systemd-resolved
readonly EXIT_CODE_CANNOT_RESTART_LAN_DEVICE=12       # Cannot start local network device (nmcli connectip up fails)
readonly EXIT_CODE_CANNOT_RESTART_DNSMASQ=13          # Cannot restart dnsmasq
readonly EXIT_CODE_CANNOT_RESTART_NM=14               # Cannot restart NetworkManager
readonly EXIT_CODE_WAN_WITH_NO_IP=15                  # Given WAN device does not have an IPv4 address
readonly EXIT_CODE_NO_GUI_FOR_ROOT=16                 # You shouldn't execute the script by root in GUI mode (use sudo instead)
readonly EXIT_CODE_CANNOT_REMOVE_FILES=17             # The script was executed with --remove, but it could not remove settings files
readonly EXIT_CODE_CANNOT_REMOVE_CONNECTION=18        # The script was executed with --remove, but it could not remove a connection
readonly EXIT_CODE_CANNOT_RESTART_DOCKER=19           # Cannot restart docker
readonly EXIT_CODE_NO_SAN_FOR_SERVER_NUMBER=20        # Obtained certificate did not contain a valid domain for this server number
readonly EXIT_CODE_CANNOT_START_DAEMON=21             # Cannot start daemon due to e.g. no network device configured by examnet, no domain in Naksu 2 workdir, etc.
readonly EXIT_CODE_DAEMON_EXITED_UNEXPECTEDLY=22      # Daemon exited unexpectedly
readonly EXIT_CODE_CANNOT_CHANGE_SERVICE_STATE=23     # Cannot change service state (e.g. enable/disable/restart) due to systemd failure
readonly EXIT_CODE_MISSING_CERTIFICATE=24             # Cannot find certificate (e.g. download failure, missing file, invalid API key)

readonly SCRIPT_PATH=$0
readonly PARAM_NET_DEVICE_WAN=$1
readonly PARAM_NET_DEVICE_LAN=$2
readonly PARAM_SERVER_NUMBER=$3
readonly PARAM_SERVER_FRIENDLY_NAME=$4

readonly NETWORK_DEVICE_FILTER_RE="^docker|^br|^veth|^lo$"
readonly DOCKER_BRIDGE_NETWORK_DNS_RESOLVER_IP="172.17.0.1"

readonly PATH_TEMPLATES=/etc/ytl-linux-digabi2-examnet/templates
readonly PATH_RESOLVED=/etc/systemd/resolved.conf.d
readonly PATH_RESOLVED_CONF=$PATH_RESOLVED/ytl-linux.conf
readonly PATH_RESOLVED_CONF_TEMPLATE=$PATH_TEMPLATES/resolved.conf.template
readonly PATH_DNSMASQ=/etc/dnsmasq.d
readonly PATH_DNSMASQ_CONF=$PATH_DNSMASQ/ytl-linux.conf
readonly PATH_DNSMASQ_CONF_TEMPLATE=$PATH_TEMPLATES/dnsmasq.conf.template
readonly PATH_DNSMASQ_STATIC_DNS_CONF=$PATH_DNSMASQ/ytl-linux-static-dns-records.conf
readonly PATH_DOCKER=/etc/docker
readonly PATH_DOCKER_DAEMON_CONF=$PATH_DOCKER/daemon.json
readonly PATH_DOCKER_DAEMON_CONF_TEMPLATE=$PATH_TEMPLATES/docker-daemon.json.template
readonly PATH_NAKSU2_WORKDIR="/home/school/.local/share/digabi/naksu2"
readonly PATH_NAKSU2_CERTS_DIR="$PATH_NAKSU2_WORKDIR/certs"
readonly PATH_NAKSU2_CERT="$PATH_NAKSU2_CERTS_DIR/cert.pem"
readonly PATH_NAKSU2_KEY="$PATH_NAKSU2_CERTS_DIR/key.pem"
readonly PATH_NAKSU2_CHAIN="$PATH_NAKSU2_CERTS_DIR/chain.pem"
readonly PATH_NAKSU2_FULLCHAIN="$PATH_NAKSU2_CERTS_DIR/fullchain.pem"
readonly PATH_NAKSU2_DOMAIN="$PATH_NAKSU2_CERTS_DIR/domain.txt"
readonly PATH_NAKSU2_CONFIG="$PATH_NAKSU2_WORKDIR/naksu2-config.json"
readonly PATH_EXAMNET_CONFIG=/etc/ytl-linux-digabi2-examnet/conf
readonly PATH_SERVER_FRIENDLY_NAME_CONF=$PATH_EXAMNET_CONFIG/server-friendly-name
readonly PATH_NET_DEVICE_LAN_CONF=$PATH_EXAMNET_CONFIG/net-device-lan
readonly PATH_NET_DEVICE_WAN_CONF=$PATH_EXAMNET_CONFIG/net-device-wan

readonly GET_SCHOOL_CERTIFICATE_URL="https://sayo.production.yo-prod.ylioppilastutkinto.fi/get-school-certificate"

readonly BIN_ECHO=/usr/bin/echo
readonly BIN_GREP=/usr/bin/grep
readonly BIN_TR=/usr/bin/tr
readonly BIN_CUT=/usr/bin/cut
readonly BIN_IP=/usr/sbin/ip
readonly BIN_MKDIR=/usr/bin/mkdir
readonly BIN_SYSTEMCTL=/usr/bin/systemctl
readonly BIN_NMCLI=/usr/bin/nmcli
readonly BIN_ZENITY=/usr/bin/zenity
readonly BIN_SED=/usr/bin/sed
readonly BIN_XARGS=/usr/bin/xargs
readonly BIN_OPENSSL=/usr/bin/openssl
readonly BIN_DIGABI2_EXAMNET_BOUNCER=/usr/local/sbin/digabi2-examnet-bouncer

readonly CONST_MIN_SERVER_NUMBER=1
readonly CONST_MAX_SERVER_NUMBER=24
readonly CONST_SUBNETS_PER_SERVER=10

function debug_path() {
    if [ -z "$DEBUG" ]; then
        $BIN_ECHO "/dev/null"
    else
        $BIN_ECHO "$DEBUG"
    fi
}

PATH_DEBUG=$(debug_path)
readonly PATH_DEBUG

function debug() {
    _DEBUG_MESSAGE=$1
    $BIN_ECHO "$SCRIPT_PATH DEBUG: $_DEBUG_MESSAGE" >>"$PATH_DEBUG"
}

function print_error() {
    _ERROR_MESSAGE=$1
    debug "ERROR: $_ERROR_MESSAGE"
    if [ $GUI_MODE -gt 0 ]; then
        $BIN_ZENITY --error --text="$_ERROR_MESSAGE"
    else
        $BIN_ECHO "$SCRIPT_PATH error: $_ERROR_MESSAGE" >&2
    fi
}

function print_info() {
    _INFO_MESSAGE=$1
    debug "INFO: $_INFO_MESSAGE"
    if [ $GUI_MODE -gt 0 ]; then
        $BIN_ZENITY --info --text="$_INFO_MESSAGE"
    else
        $BIN_ECHO "$SCRIPT_PATH info: $_INFO_MESSAGE"
    fi
}

function print_usage() {
    $BIN_ECHO "usage: $SCRIPT_PATH wan-network-device local-network-device server-number [custom-server-name] [--download-certificate] [--use-static-local-dns]" >&2
    $BIN_ECHO "       $SCRIPT_PATH --gui" >&2
    $BIN_ECHO "       $SCRIPT_PATH --daemon" >&2
    $BIN_ECHO "       $SCRIPT_PATH --remove" >&2
    $BIN_ECHO "" >&2
    $BIN_ECHO "example: $SCRIPT_PATH eth0 eth1 1" >&2
}

function exit_script() {
    _EXIT_CODE=$1
    debug "Exiting with code $_EXIT_CODE"
    exit "$_EXIT_CODE"
}

function exit_if_error() {
    _EXIT_CODE=$(($1))
    _EXIT_CODE_IF_ERROR=$(($2))
    _ERROR_MESSAGE_IF_ERROR=$3

    if [ $_EXIT_CODE -gt 0 ]; then
        debug "Got exit code $_EXIT_CODE"
        print_error "$_ERROR_MESSAGE_IF_ERROR (original exit code: $_EXIT_CODE)"
        exit_script $_EXIT_CODE_IF_ERROR
    fi
}

function current_user_is_root () {
    if [ "$EUID" == "0" ]; then
        echo 1
    fi
}

function current_user_is_sudo () {
    if [ "$SUDO_UID" ] ; then
        echo 1
    fi
}

function network_enumerate_devices () {
    for dir in /sys/class/net/*; do
        device=$(basename "$dir")
        if ! [[ "$device" =~ $NETWORK_DEVICE_FILTER_RE ]]; then
            echo "$device "
        fi
    done
}

function network_enumerate_devices_with_information () {
    device_to_skip=$1
    
    devices=$(network_enumerate_devices)

    for device in $devices; do
        if [ -n "$device_to_skip" ] && [ "$device" == "$device_to_skip" ]; then
            continue
        fi
        
        ip=$(ip addr show dev "$device" | grep "inet " | awk '{print $2}' | cut -d/ -f1)
        if [ -z "$ip" ]; then
            ip=-
        fi

        connect=$(ip link show dev "$device" | grep -q "state UP" && echo "Connected" || echo "Disconnected")
        if [ -z "$connect" ]; then
            connect=-
        fi

        echo "$device" "$ip" "$connect"
    done
}

function ask_network_device () {
    question=$1
    device_to_skip=$2
    
    devices=$(network_enumerate_devices_with_information "$device_to_skip")

    # shellcheck disable=SC2086
    $BIN_ZENITY --list --title "$question" \
        --column "Device" --column "IPv4" --column "Connection" \
        --width=400 --height=400 \
        $devices
}


function network_device_exists() {
    _DEVICE=$1
    $BIN_IP link show "$_DEVICE" &> /dev/null && $BIN_ECHO "1"
}

function get_ipv4_address() {
    _DEVICE=$1
    _IP=$($BIN_IP -oneline -4 addr show scope global "$_DEVICE" | $BIN_TR -s ' ' | $BIN_TR '/' ' ' | $BIN_CUT -f 4 -d ' ')
    if [[ ! "$_IP" =~ "does not exist" ]]; then
        $BIN_ECHO "$_IP"
    fi
}

function check_network_device_names() {
    _NET_DEVICE_WAN=$1
    _NET_DEVICE_LAN=$2

    if [ -z "$_NET_DEVICE_WAN" ]; then
        print_error "Network device name (internet) is missing"
        print_usage
        exit_script $EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_WAN
    fi

    WAN_NETWORK_DEVICE_EXISTS=$(network_device_exists "$_NET_DEVICE_WAN")
    if [ -z "$WAN_NETWORK_DEVICE_EXISTS" ]; then
        print_error "Given network device $_NET_DEVICE_WAN (internet) does not exist"
        print_usage
        exit_script $EXIT_CODE_NETWORK_DEVICE_MISSING_WAN
    fi

    if [ -z "$_NET_DEVICE_LAN" ]; then
        print_error "Network device name (local network) is missing"
        print_usage
        exit_script $EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_LAN
    fi

    LAN_NETWORK_DEVICE_EXISTS=$(network_device_exists "$_NET_DEVICE_LAN")
    if [ -z "$LAN_NETWORK_DEVICE_EXISTS" ]; then
        print_error "Given network device $_NET_DEVICE_LAN (local network) does not exist"
        print_usage
        exit_script $EXIT_CODE_NETWORK_DEVICE_MISSING_LAN
    fi

    if [ "$_NET_DEVICE_WAN" = "$_NET_DEVICE_LAN" ]; then
        print_error "Two different network device names are required"
        print_usage
        exit_script $EXIT_CODE_IDENT_NETWORK_DEVICE_NAMES
    fi
}

function server_number_is_valid() {
    _SERVER_NUMBER=$1
    if [[ "$_SERVER_NUMBER" =~ ^[0-9]+$ ]] && [ "$_SERVER_NUMBER" -ge $CONST_MIN_SERVER_NUMBER ] && [ "$_SERVER_NUMBER" -le $CONST_MAX_SERVER_NUMBER ]; then
        $BIN_ECHO "1"
    fi
}

function check_server_number() {
    _SERVER_NUMBER=$1

    if [ -z "$_SERVER_NUMBER" ]; then
        print_error "Server number is missing"
        print_usage
        exit_script $EXIT_CODE_MISSING_SERVER_NUMBER
    fi

    if [ -z "$(server_number_is_valid "$_SERVER_NUMBER")" ]; then
        print_error "Server number must be $CONST_MIN_SERVER_NUMBER-$CONST_MAX_SERVER_NUMBER"
        print_usage
        exit_script $EXIT_CODE_ILLEGAL_SERVER_NUMBER
    fi
}

function get_lan_ip_prefix() {
    _IP_WAN=$1

    if [[ "$_IP_WAN" =~ ^192\.168\. ]]; then
        $BIN_ECHO "10.0."
    else
        $BIN_ECHO "192.168."
    fi
}

function write_file() {
    _FILE_FILENAME=$1
    _FILE_CONTENT=$2

    _FILE_PATH=$(dirname "$_FILE_FILENAME")
    if [ ! -d "$_FILE_PATH" ]; then
        debug "Path $_FILE_PATH is missing, creating"
        $BIN_MKDIR -p "$_FILE_PATH"
        exit_if_error $? $EXIT_CODE_BAD_FILE_PATH "Failed to create directory $_FILE_PATH"
    else
        debug "Path $_FILE_PATH exists"
    fi

    debug "$_FILE_FILENAME: $_FILE_CONTENT"
    $BIN_ECHO -e "$_FILE_CONTENT" >"$_FILE_FILENAME"
    exit_if_error $? $EXIT_CODE_CANNOT_WRITE "Failed to write to $_FILE_FILENAME"
}

function configure_networkmanager() {
    _CONNECTION_NAME=$1
    _INTERFACE_NAME=$2
    _IP_AND_NETMASK=$3

    debug "Deleting existing NetworkManager connection '$_CONNECTION_NAME'"
    $BIN_NMCLI connection delete "$_CONNECTION_NAME" >>"$PATH_DEBUG" 2>&1
    # We are not checking the exit code as this command fails if the connection does not exist
    # This is quite normal if the script has been executed before

    debug "Adding NetworkManager connection '$_CONNECTION_NAME'"
    $BIN_NMCLI connection add \
        type ethernet \
        ifname "$_INTERFACE_NAME" \
        con-name "$_CONNECTION_NAME" \
        ip4 "$_IP_AND_NETMASK" \
        autoconnect yes \
        save yes >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_LAN_DEVICE "NetworkManager CLI: connection add $_CONNECTION_NAME failed"
    
    debug "Disabling IPv6 in connection '$_CONNECTION_NAME'"
    $BIN_NMCLI connection modify "$_CONNECTION_NAME" ipv6.method "disabled" >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_LAN_DEVICE "NetworkManager CLI: IPv6 disable failed"
    
    debug "Starting connection '$_CONNECTION_NAME'"
    $BIN_NMCLI connection up "$_CONNECTION_NAME" >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_LAN_DEVICE "Failed to start NetworkManager connection '$_CONNECTION_NAME'"
}

function remove_dnsmasq_settings() {
    if [ -f $PATH_DNSMASQ_CONF ]; then
        rm -f $PATH_DNSMASQ_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_DNSMASQ_CONF'"
    fi

    if [ -f $PATH_DNSMASQ_STATIC_DNS_CONF ]; then
        rm -f $PATH_DNSMASQ_STATIC_DNS_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_DNSMASQ_STATIC_DNS_CONF'"
    fi
}

function remove_all_settings() {
    disable_examnet_daemon

    if [ -f $PATH_RESOLVED_CONF ]; then
        rm -f $PATH_RESOLVED_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_RESOLVED_CONF'"
    fi

    if [ -f $PATH_DOCKER_DAEMON_CONF ]; then
        rm -f $PATH_DOCKER_DAEMON_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_DOCKER_DAEMON_CONF'"
    fi

    if [ -f $PATH_NET_DEVICE_WAN_CONF ]; then
        rm -f $PATH_NET_DEVICE_WAN_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_NET_DEVICE_WAN_CONF'"
    fi

    if [ -f $PATH_NET_DEVICE_LAN_CONF ]; then
        rm -f $PATH_NET_DEVICE_LAN_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_NET_DEVICE_LAN_CONF'"
    fi

    if [ -f $PATH_SERVER_FRIENDLY_NAME_CONF ]; then
        rm -f $PATH_SERVER_FRIENDLY_NAME_CONF
        exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_FILES "Failed to remove system file '$PATH_SERVER_FRIENDLY_NAME_CONF'"
    fi

    remove_dnsmasq_settings

    $BIN_NMCLI -f UUID,NAME connection show | $BIN_GREP -P -v "^UUID" | $BIN_TR -s ' ' | while read -r line ; do
        connection_uuid=$(echo "$line" | $BIN_CUT -d ' ' -f 1)
        connection_name=$(echo "$line" | $BIN_CUT -d ' ' -f 2)
        if [[ "$connection_name" =~ ^yo- ]]; then
            debug "Removing connection '$connection_name', uuid: $connection_uuid"
            $BIN_NMCLI connection delete "$connection_uuid"
            exit_if_error $? $EXIT_CODE_CANNOT_REMOVE_CONNECTION "Failed to remove connection '$connection_name'"
        fi
    done
}

function restart_network_services() {
    $BIN_SYSTEMCTL restart systemd-resolved
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_RESOLVED "Failed to restart systemd-resolved"

    $BIN_SYSTEMCTL restart dnsmasq >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_DNSMASQ "Failed to restart dnsmasq"

    $BIN_SYSTEMCTL restart NetworkManager.service >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_NM "Failed to restart NetworkManager.service"

    if [[ "$(systemctl is-enabled ytl-linux-digabi2-examnet.service)" == "enabled" ]]; then
        $BIN_SYSTEMCTL restart ytl-linux-digabi2-examnet.service >>"$PATH_DEBUG" 2>&1
        exit_if_error $? $EXIT_CODE_CANNOT_CHANGE_SERVICE_STATE "Failed to restart ytl-linux-digabi2-examnet.service"
    fi
}

function enable_examnet_daemon() {
    $BIN_SYSTEMCTL enable ytl-linux-digabi2-examnet.service >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_CHANGE_SERVICE_STATE "Failed to enable ytl-linux-digabi2-examnet.service"
}

function disable_examnet_daemon() {
    $BIN_SYSTEMCTL disable --now ytl-linux-digabi2-examnet.service >>"$PATH_DEBUG" 2>&1
    exit_if_error $? $EXIT_CODE_CANNOT_CHANGE_SERVICE_STATE "Failed to stop ytl-linux-digabi2-examnet.service"
}

function restart_docker() {
    $BIN_SYSTEMCTL restart docker
    exit_if_error $? $EXIT_CODE_CANNOT_RESTART_DOCKER "Failed to restart docker"
}

function request_api_key_manually() {
  print_error "Naksu 2 has not completed initial setup; API key cannot be automatically retrieved for certificate obtainment."
  read -rp "Please enter the API key manually: " _API_KEY
  $BIN_ECHO "$_API_KEY"
}

# FIXME: Temporary reimplementation of logic that already exists in Naksu 2, since we cannot fit examnet logic into Naksu easily right now (27.10.2025)
function retrieve_naksu2_api_key() {
    if [ ! -f $PATH_NAKSU2_CONFIG ]; then
        _API_KEY="$(request_api_key_manually)"
    else
        _API_KEY="$(jq -r '.apiKey | select(.)' $PATH_NAKSU2_CONFIG)"

        if [ "$_API_KEY" == "" ]; then
            _API_KEY="$(request_api_key_manually)"
        fi
    fi

    $BIN_ECHO "$_API_KEY"
}

function download_static_cert() {
    debug "Downloading static certificate"
    _API_KEY="$(retrieve_naksu2_api_key)"
    CERTIFICATE=$(curl --silent --show-error --fail "$GET_SCHOOL_CERTIFICATE_URL" -H "X-API-Key: $_API_KEY")
    CURL_EXIT_CODE=$?
    if [ $CURL_EXIT_CODE -ne 0 ] || [ -z "$CERTIFICATE" ]; then
        print_error "Failed to download certificate"
        exit_script $EXIT_CODE_CANNOT_WRITE
    fi
    SCHOOL_NUMBER=$(printf '%s' "$CERTIFICATE" | jq -r .schoolNumber)
    if [ "$SCHOOL_NUMBER" == "null" ] || [ -z "$SCHOOL_NUMBER" ]; then
        print_error "Downloaded certificate has no schoolNumber"
        exit_script $EXIT_CODE_CANNOT_WRITE
    fi
    CERTIFICATE_VALID_UNTIL=$(printf '%s' "$CERTIFICATE" | jq -r .certificateValidUntil)
    if [ "$CERTIFICATE_VALID_UNTIL" == "null" ] || [ -z "$CERTIFICATE_VALID_UNTIL" ]; then
        print_error "Downloaded certificate has no certificateValidUntil date"
        exit_script $EXIT_CODE_CANNOT_WRITE
    fi
    debug "School $SCHOOL_NUMBER got certificate that is valid until $CERTIFICATE_VALID_UNTIL"

    printf '%s' "$CERTIFICATE" | jq -r .cert > $PATH_NAKSU2_CERT
    printf '%s' "$CERTIFICATE" | jq -r .key > $PATH_NAKSU2_KEY
    printf '%s' "$CERTIFICATE" | jq -r .chain > $PATH_NAKSU2_CHAIN
    printf '%s' "$CERTIFICATE" | jq -r .cert,.chain > $PATH_NAKSU2_FULLCHAIN
    debug "Stored certificates in directory $PATH_NAKSU2_CERTS_DIR"
}

function configure_static_dns_records() {
    _SERVER_NUMBER=$1

    if [ ! -f "$PATH_NAKSU2_CERT" ]; then
        print_error "Certificate file $PATH_NAKSU2_CERT does not exist, cannot configure static DNS records"
        exit_script $EXIT_CODE_MISSING_CERTIFICATE
    fi

    debug "Configuring static DNS records"
    debug "Parsing domains from certificate in $PATH_NAKSU2_CERT"

    # Parse out SANs from certificate; only include server subdomains (e.g. ktp1.1000.koe.abitti.net), not the "root subdomain"
    # (e.g. 1000.koe.abitti.net) since we cannot reasonably ascribe DNS names to these
    DOMAINS="$(
        $BIN_OPENSSL x509 -in "$PATH_NAKSU2_CERT" -text -noout |\
        $BIN_GREP DNS: |\
        $BIN_XARGS |\
        $BIN_SED 's/DNS://g' |\
        $BIN_SED 's/, /\n/g' |\
        $BIN_GREP -E '(.+\..+){4}'
    )"

    debug "Configuring static DNS records for the following domains:"
    debug "$DOMAINS"

    DNS_RECORDS=()
    ETC_HOSTS=()
    THIS_SERVER_DOMAIN=""

    for DOMAIN in $DOMAINS; do
        debug "Generating DNS record for domain: $DOMAIN"

        SERVER_NUMBER="$($BIN_ECHO "$DOMAIN" | $BIN_CUT -d '.' -f1 | $BIN_TR -dc '[:digit:]')"

        if [ "$SERVER_NUMBER" == "$_SERVER_NUMBER" ]; then
            THIS_SERVER_DOMAIN=$DOMAIN
        fi

        debug "Server number of domain $DOMAIN is: $SERVER_NUMBER"
        IP="${IP_LAN_PREFIX}$((SERVER_NUMBER * CONST_SUBNETS_PER_SERVER)).1"
        DNS_RECORDS+=("host-record=$DOMAIN,$IP")
        ETC_HOSTS+=("$IP $DOMAIN")
    done

    if [ "$THIS_SERVER_DOMAIN" == "" ]; then
        print_error "Certificate did not contain a valid domain for this server number"
        exit_script $EXIT_CODE_NO_SAN_FOR_SERVER_NUMBER
    fi

    debug "Generated DNS records: ${DNS_RECORDS[*]}"
    write_file $PATH_DNSMASQ_STATIC_DNS_CONF "$(IFS=$'\n'; $BIN_ECHO "${DNS_RECORDS[*]}")"

    debug "Generated /etc/hosts entries: ${ETC_HOSTS[*]}"

    # Clean up old entries
    $BIN_SED -i '/^# BEGIN SCHOOL DOMAIN ENTRIES$/,/^# END SCHOOL DOMAIN ENTRIES$/d' /etc/hosts

    {
    echo "# BEGIN SCHOOL DOMAIN ENTRIES"
    printf '%s\n' "${ETC_HOSTS[@]}"
    echo "# END SCHOOL DOMAIN ENTRIES"
    } | sudo tee -a /etc/hosts > /dev/null

    debug "Configuring domain for KTP"
    debug "This server's domain based on server number ($SERVER_NUMBER) is: $THIS_SERVER_DOMAIN"
    write_file $PATH_NAKSU2_DOMAIN "$THIS_SERVER_DOMAIN"
}

# ---------- Main script logic starts here ---------- #

if [ -z "$PARAM_NET_DEVICE_WAN" ]; then
    print_usage
    exit_script $EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_WAN
fi

GUI_MODE=0

if [ ! "$(current_user_is_root)" ]; then
    print_error "You're not root"
    exit_script $EXIT_CODE_MUST_BE_ROOT
fi

if [[ $* == *--daemon* ]]; then
    print_info "Starting in daemon mode"

    if [[ ! -f $PATH_NET_DEVICE_LAN_CONF || ! -f $PATH_SERVER_FRIENDLY_NAME_CONF ]]; then
        print_error "Examnet is not configured, daemon cannot start"
        exit_script $EXIT_CODE_CANNOT_START_DAEMON
    fi

    _LAN_DEVICE_IP=$(get_ipv4_address "$(cat $PATH_NET_DEVICE_LAN_CONF)")

    if [ -z "$_LAN_DEVICE_IP" ]; then
        print_error "Could not find an IPv4 address for the LAN network device as configured by examnet, daemon cannot start"
        exit_script $EXIT_CODE_CANNOT_START_DAEMON
    fi

    if [[ ! $PATH_NAKSU2_WORKDIR || ! -f $PATH_NAKSU2_DOMAIN ]]; then
        print_error "Abitti 2 server is not configured (missing Naksu 2 workdir and/or domain.txt), daemon cannot start"
        exit_script $EXIT_CODE_CANNOT_START_DAEMON
    fi

    $BIN_DIGABI2_EXAMNET_BOUNCER \
        --friendly-name-file $PATH_SERVER_FRIENDLY_NAME_CONF \
        --dns-hostname-file $PATH_NAKSU2_DOMAIN \
        --ncsi-hostnames-file $PATH_EXAMNET_CONFIG/ncsi-hostnames \
        --mdns-hostname-output-file $PATH_EXAMNET_CONFIG/mdns-hostname-output \
        --bind-addr "$_LAN_DEVICE_IP" \
        --bind-port 80

    # We're not supposed to get here, so this would indicate the daemon process exited
    exit_script $EXIT_CODE_DAEMON_EXITED_UNEXPECTEDLY
fi

if [[ $* == *--remove* ]]; then
    remove_all_settings
    restart_network_services

    print_info "All examnet settings have been removed"

    exit_script 0
fi

DOWNLOAD_CERTIFICATE=0

if [[ $* == *--download-certificate* ]]; then
    DOWNLOAD_CERTIFICATE=1
fi

USE_STATIC_LOCAL_DNS=0

if [[ $* == *--use-static-local-dns* ]]; then
    USE_STATIC_LOCAL_DNS=1
fi

if [[ $* == *--gui* ]]; then
    if [ ! "$(current_user_is_sudo)" ]; then
        print_error "GUI mode cannot be executed as root, since typically root does not have access to user's desktop session"
        exit_script $EXIT_CODE_NO_GUI_FOR_ROOT
    fi

    GUI_MODE=1
    NET_DEVICE_WAN=$(ask_network_device "Select internet (WAN) network device")
    if [ -z "$NET_DEVICE_WAN" ]; then
        print_error "Missing WAN network device name"
        exit_script $EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_WAN
    fi
else
    NET_DEVICE_WAN=$PARAM_NET_DEVICE_WAN
fi

if [ $GUI_MODE -gt 0 ]; then
    NET_DEVICE_LAN=$(ask_network_device "Select local (LAN) network device" "$NET_DEVICE_WAN")
    if [ -z "$NET_DEVICE_LAN" ]; then
        print_error "Missing LAN network device name"
        exit_script $EXIT_CODE_NETWORK_DEVICE_NAME_MISSING_LAN
    fi
else
    NET_DEVICE_LAN=$PARAM_NET_DEVICE_LAN
fi

debug "NET_DEVICE_WAN: $NET_DEVICE_WAN"
debug "NET_DEVICE_LAN: $NET_DEVICE_LAN"
check_network_device_names "$NET_DEVICE_WAN" "$NET_DEVICE_LAN"

if [ $GUI_MODE -gt 0 ]; then
    SERVER_NUMBER=$($BIN_ZENITY --entry --title="Server number" --text="Enter server number ($CONST_MIN_SERVER_NUMBER-$CONST_MAX_SERVER_NUMBER)")
else
    SERVER_NUMBER=$PARAM_SERVER_NUMBER
fi

debug "SERVER_NUMBER: $SERVER_NUMBER"
check_server_number "$SERVER_NUMBER"

write_file $PATH_EXAMNET_CONFIG/net-device-lan "$NET_DEVICE_LAN"
write_file $PATH_EXAMNET_CONFIG/net-device-wan "$NET_DEVICE_WAN"

export NET_DEVICE_WAN
export NET_DEVICE_LAN

IP_WAN=$(get_ipv4_address "$NET_DEVICE_WAN")
readonly IP_WAN
if [ -z "$IP_WAN" ]; then
    print_error "Given WAN device $NET_DEVICE_WAN does not have an IPv4 address"
    exit_script $EXIT_CODE_WAN_WITH_NO_IP
fi

IP_LAN=$(get_ipv4_address "$NET_DEVICE_LAN")
readonly IP_LAN
if [ -n "$IP_LAN" ]; then
    print_info "Given local device $NET_DEVICE_LAN has already an IPv4 address $IP_LAN"
fi
debug "IP_WAN: $IP_WAN"
debug "IP_LAN: $IP_LAN"

export IP_WAN
export IP_LAN
export SERVER_NUMBER

IP_LAN_PREFIX=$(get_lan_ip_prefix "$IP_WAN")
export IP_LAN_PREFIX

export DOCKER_BRIDGE_NETWORK_DNS_RESOLVER_IP

debug "SUBNETS_PER_SERVER: $CONST_SUBNETS_PER_SERVER"

SERVER_HOST_NUMBER=$((SERVER_NUMBER * CONST_SUBNETS_PER_SERVER))
debug "SERVER_HOST_NUMBER: $SERVER_HOST_NUMBER"

SERVER_OWN_IP="$IP_LAN_PREFIX$SERVER_HOST_NUMBER.1"
debug "SERVER_OWN_IP: $SERVER_OWN_IP"

export SERVER_OWN_IP

DHCP_RANGE_START="$IP_LAN_PREFIX$SERVER_HOST_NUMBER.10"
DHCP_RANGE_END="$IP_LAN_PREFIX$((SERVER_HOST_NUMBER + CONST_SUBNETS_PER_SERVER - 1)).254"

debug "DHCP_RANGE_START: $DHCP_RANGE_START"
debug "DHCP_RANGE_END: $DHCP_RANGE_END"

export DHCP_RANGE_START
export DHCP_RANGE_END

NCSI_HOSTNAMES_LIST=$(cat $PATH_EXAMNET_CONFIG/ncsi-hostnames)
debug "NCSI_HOSTNAMES_LIST: $NCSI_HOSTNAMES_LIST"
export NCSI_HOSTNAMES_LIST

if [ $DOWNLOAD_CERTIFICATE -gt 0 ]; then
    download_static_cert
fi

write_file $PATH_RESOLVED_CONF "$(envsubst < $PATH_RESOLVED_CONF_TEMPLATE)"
write_file $PATH_DOCKER_DAEMON_CONF "$(envsubst < $PATH_DOCKER_DAEMON_CONF_TEMPLATE)"

remove_dnsmasq_settings
write_file $PATH_DNSMASQ_CONF "$(envsubst < $PATH_DNSMASQ_CONF_TEMPLATE)"

if [ $USE_STATIC_LOCAL_DNS -gt 0 ]; then
    configure_static_dns_records "$SERVER_NUMBER"
fi

if [[ $GUI_MODE -gt 0 ]]; then
        SERVER_FRIENDLY_NAME=$($BIN_ZENITY --entry --title="Custom server name" --text="Enter custom name for this server, e.g. 'classroom' (leave empty for no custom name)")
else
    if [[ ! $PARAM_SERVER_FRIENDLY_NAME =~ ^--.+$ ]]; then
        SERVER_FRIENDLY_NAME=$PARAM_SERVER_FRIENDLY_NAME
    else
        SERVER_FRIENDLY_NAME=""
    fi
fi

if [ -z "$SERVER_FRIENDLY_NAME" ]; then
    debug "User did not provide friendly name, falling back to static DNS name"
    # Fallback to use server's static DNS name (e.g. ktp1)
    SERVER_FRIENDLY_NAME=$(cat $PATH_NAKSU2_DOMAIN | cut -d '.' -f1)
fi

debug "SERVER_FRIENDLY_NAME: $SERVER_FRIENDLY_NAME"

write_file $PATH_SERVER_FRIENDLY_NAME_CONF "$SERVER_FRIENDLY_NAME"

configure_networkmanager "yo-$NET_DEVICE_LAN" "$NET_DEVICE_LAN" "$SERVER_OWN_IP/16"

# Remove configuration file generated by cloud-init
# If not removed, there might be multiple settings for built-in ethernet devices
if [ -f /etc/netplan/50-cloud-init.yaml ]; then
    rm /etc/netplan/50-cloud-init.yaml
fi

enable_examnet_daemon
restart_network_services
restart_docker

print_info "Changes made successfully"
